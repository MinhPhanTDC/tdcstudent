/**
 * Bulk import service for student accounts
 * Requirements: 4.6, 4.7, 4.8, 4.9, 4.10
 */

import { studentService } from '@tdc/firebase';
import type { ImportRow, ImportResult, ImportFailure, CreateStudentInput } from '@tdc/schemas';
import type { ValidationResult } from './validator';
import { getValidRows } from './validator';

/**
 * Import options
 */
export interface ImportOptions {
  /** Rate limit in accounts per second (default: 10) */
  rateLimit?: number;
  /** Whether to skip duplicate emails (default: true) */
  skipDuplicates?: boolean;
}

/**
 * Import callbacks for progress tracking
 */
export interface ImportCallbacks {
  /** Called when progress updates */
  onProgress?: (current: number, total: number) => void;
  /** Called when a single row is processed */
  onRowProcessed?: (email: string, success: boolean, error?: string) => void;
  /** Called when import is cancelled */
  onCancelled?: () => void;
}

/**
 * Import controller for cancellation
 */
export interface ImportController {
  cancel: () => void;
  isCancelled: () => boolean;
}

/**
 * Create an import controller for cancellation support
 */
export function createImportController(): ImportController {
  let cancelled = false;
  return {
    cancel: () => {
      cancelled = true;
    },
    isCancelled: () => cancelled,
  };
}

/**
 * Rate limiter to ensure we don't exceed Firebase quotas
 * Default: 10 accounts per second = 100ms between each
 */
async function rateLimitDelay(rateLimit: number): Promise<void> {
  const delayMs = Math.ceil(1000 / rateLimit);
  await new Promise((resolve) => setTimeout(resolve, delayMs));
}

/**
 * Convert ImportRow to CreateStudentInput
 */
function toStudentInput(row: ImportRow): CreateStudentInput {
  return {
    email: row.email.toLowerCase().trim(),
    displayName: row.name.trim(),
    // Password will be auto-generated by studentService
  };
}

/**
 * Import students from validated rows
 * - Creates student accounts only for valid rows
 * - Implements rate limiting (default 10/second)
 * - Tracks success/failure for each row
 * - Generates import result summary
 */
export async function importStudents(
  validationResult: ValidationResult,
  options: ImportOptions = {},
  callbacks: ImportCallbacks = {},
  controller?: ImportController
): Promise<ImportResult> {
  const { rateLimit = 10, skipDuplicates = true } = options;
  const { onProgress, onRowProcessed, onCancelled } = callbacks;

  // Get only valid rows for import
  const validRows = getValidRows(validationResult);
  const total = validRows.length;

  const failures: ImportFailure[] = [];
  let successCount = 0;
  let failureCount = 0;

  // Track emails we've already processed to handle duplicates
  const processedEmails = new Set<string>();

  for (let i = 0; i < validRows.length; i++) {
    // Check for cancellation
    if (controller?.isCancelled()) {
      onCancelled?.();
      break;
    }

    const row = validRows[i];
    const email = row.email.toLowerCase().trim();
    const rowNumber = validationResult.validatedRows.findIndex(
      (r) => r.email.toLowerCase().trim() === email && r.isValid
    ) + 1;

    // Report progress
    onProgress?.(i + 1, total);

    // Skip if we've already processed this email in this import
    if (skipDuplicates && processedEmails.has(email)) {
      failures.push({
        row: rowNumber,
        email,
        reason: 'Email đã được xử lý trong lần import này',
      });
      failureCount++;
      onRowProcessed?.(email, false, 'Email đã được xử lý trong lần import này');
      continue;
    }

    try {
      const studentInput = toStudentInput(row);
      const result = await studentService.createStudentWithAuth(studentInput);

      if (result.success) {
        successCount++;
        processedEmails.add(email);
        onRowProcessed?.(email, true);
      } else {
        failureCount++;
        const reason = result.error.message || 'Lỗi không xác định';
        failures.push({
          row: rowNumber,
          email,
          reason,
        });
        onRowProcessed?.(email, false, reason);
      }
    } catch (error) {
      failureCount++;
      const reason = error instanceof Error ? error.message : 'Lỗi không xác định';
      failures.push({
        row: rowNumber,
        email,
        reason,
      });
      onRowProcessed?.(email, false, reason);
    }

    // Rate limiting - delay before next creation (except for last item)
    if (i < validRows.length - 1 && !controller?.isCancelled()) {
      await rateLimitDelay(rateLimit);
    }
  }

  return {
    totalRows: validationResult.validatedRows.length,
    validRows: validationResult.validCount,
    invalidRows: validationResult.invalidCount,
    successCount,
    failureCount,
    failures,
  };
}

/**
 * Generate a downloadable failure report
 */
export function generateFailureReport(result: ImportResult): string {
  const lines: string[] = [
    '# Báo cáo Import Học viên',
    '',
    '## Tổng quan',
    `- Tổng số dòng: ${result.totalRows}`,
    `- Dòng hợp lệ: ${result.validRows}`,
    `- Dòng không hợp lệ: ${result.invalidRows}`,
    `- Import thành công: ${result.successCount}`,
    `- Import thất bại: ${result.failureCount}`,
    '',
  ];

  if (result.failures.length > 0) {
    lines.push('## Chi tiết lỗi');
    lines.push('');
    lines.push('| Dòng | Email | Lý do |');
    lines.push('|------|-------|-------|');

    for (const failure of result.failures) {
      lines.push(`| ${failure.row} | ${failure.email} | ${failure.reason} |`);
    }
  }

  return lines.join('\n');
}

/**
 * Generate CSV failure report for download
 */
export function generateFailureCSV(result: ImportResult): string {
  const lines: string[] = ['Dòng,Email,Lý do'];

  for (const failure of result.failures) {
    // Escape CSV values
    const email = `"${failure.email.replace(/"/g, '""')}"`;
    const reason = `"${failure.reason.replace(/"/g, '""')}"`;
    lines.push(`${failure.row},${email},${reason}`);
  }

  return lines.join('\n');
}
